title Golem Brass P2P protocol - prototype

participantspacing equal

actor "Requestor" as Requestor#violet

actor "Provider" as Provider#springgreen

boundary "Ethereum" as Ethereum#dodgerblue

database "hyperG" as hyperG#darkkhaki

#boundary "Kademlia" as Kademlia

#participant, actor, boundary, control, entity, database
#Actors can only talk to boundary objects.
#Boundary objects can only talk to controllers and actors.
#Entity objects can only talk to controllers.
#Controllers can talk to boundary objects and entity objects, and to other controllers, but not to actors

==Initialization==
parallel
box over Requestor:sdfsdf

box over Provider:sdfsdf
parallel off


==Task definition==

parallel
box over Requestor: expectations:\n- noOfProviders < Constant\n- amountOfMoney\n- noOfSubtasks\n- valueOfSubtask\n- deadline\n- networkSubsetMask

box over Provider: capabilities:\n- minValue\n- computationalPower\n- memoryCapacity
parallel off

box over Requestor:payload:\n- urlToData\n- projectFile

==Broadcast==


parallel
Requestor -> Requestor: broadcast
Requestor -> Provider: broadcast
parallel off

box over Requestor: task is broadcasted

Requestor <- Provider: a connection is established

Requestor <-> Provider: Diffie–Hellman key exchange

parallel
box over Requestor: sharedKey
box over Provider: sharedKey
parallel off


Requestor <- Provider: Task commit

Requestor <- Provider: Task reject

Requestor -> Provider: Commit acknowledgement

==Ethereum contract==

box over Requestor:k calculated
box over Requestor:k - minimal number of chunks\nshould be known for whole group,\ni.e., requestor and all providers
note right of Requestor #yellow:todo:\nk wymaga przemyślenia\nk > noOfProviders\nk > noOfSubtasks
Requestor -> Ethereum:contract(\n providers,\n noOfSubtasks,\n priceOfSingleSubtask,\n requestorDepositForTaskCalculation,\n k\n)





rbox over Ethereum: init(noOfSubtasksProvided = noOfProviders);

box over Ethereum: noOfSubtasksProvided

==Initialization==




==Payload replication==

Requestor -> hyperG: upload(task, payload)

Requestor -> Provider: provides url to (task, payload)

Provider -> hyperG: download(task, payload)

Requestor <- Provider: payload confirmation

==Subtask assignment==


rbox over Provider:check(noOfSubtasksProvided < noOfSubtasks);

box over Provider: Only this provider\ncan get a new subtask\nthat has just finished\nprevious calculations

Requestor<-Provider:ask for subtask to be calculated
Requestor -> Provider: deliver subtask


==Subtask has been calculated by provider==

box over Provider: calculatedOutput


rbox over Provider: chunks[] = partition(calculatedOutput, k);\nmainKey = generateKey();\n(key_1, ..., key_k) = KDF(mainKey, 1, ..., k);\nmacs = (mac_1, ..., mac_k) =\n        sign(generate(chunks[i], sharedKey), providerPrivateKey);\nfor i = 1 to k do {\n    encodedChunks.\n       append(sign(encode((chunks[i], mac_i), key_i), providerPrivateKey));\n}

Provider -> hyperG: upload (encodedChunks.append, macs)

Provider -> Requestor: provides url to (encodedChunks, macs)

Requestor -> hyperG: download (encodedChunks.append, macs)

Requestor -> Provider: give me p keys, (p < P) && (1 < p < k)

note right of Requestor#yellow: todo\np musi być ograniczone\ni zależy silnie od liczby\nproviderów i subtasków

Provider -> Requestor: returns p keys, p_i in (key_1, ..., key_k)

rbox over Requestor: forEach p_i {\n   decode(encodedChunks[i], p_i);\n}

rbox over Requestor: checkMacs();

rbox over Requestor: crossCheck(decodedChunks);

Requestor -> Ethereum: provides selected p_i (p_i, i)

note right of Requestor#yellow: single p_i is sufficient to allow\nprovider withdraw money

parallel
Provider -#blue> Ethereum: provides mainKey
Provider -#green> Requestor: provides mainKey
parallel off

rbox over Ethereum: noOfSubtasksProvided\++;

note right of Provider#yellow: withdrawing of the money\ncan be done later...

Ethereum -> Provider: transfer money

==subtask calculated, money transfered==
